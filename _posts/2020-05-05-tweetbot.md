---
layout: post
title: Twitter-bot 
date: 2020-05-05 01:29
summary: Build a twitter bot and deploy it on Heroku
categories: jekyll pixyll
---

A Twitter bot allows us to control a Twitter account via the Twitter API. We could make our bot to tweet, retweet, like or follow from our account, and the best part would be that it does all these taks autonomously. 

## Pre-requisites:
If you have some basic knowledge about Git and Python, the tutorial would be really easy to follow. But don't worry if you have just started the journey, every doubt is just one Google search away.
To start off things, you will need-
* Python programming environment
* A Twitter account


## Setting up Twitter and tweepy
* Create a Twitter account. 
> I will advise you to give the bot its own account than your primary account as we will be using it for testing. 

* After creating the account go to [Twitter's developer portal](https://developer.twitter.com/en/portal/dashboard) to create a new app while being logged in from bot’s account. While creating the twitter app, If asked for app’s website you could fill in your GitHub URL where your project might be.

* You should get your Consumer Key, Consumer Secret, Access Token, and Access Token Secret after creating the app.

* Create a directory for your project and move into it. Then create a tweetbot.py file inside the directory.
```ruby
foo@bar:~$ mkdir tweetbot
foo@bar:~$ cd tweetbot
foo@bar:~/tweetbot$ nano tweetbot.py
``` 

* Install tweepy in your python environment which is required to access Twitter's API and import it into tweetbot.py file.
```ruby
foo@bar:~/tweetbot$ pip install tweepy

import tweepy
```

* Create another file with name credentials.py to store Twitter Consumer Key, Consumer Secret, Access Token, and Access Token Secret.
```ruby
foo@bar:~/tweetbot$ nano credentials.py 

consumer_key = 'your_consumer_key'
consumer_secret = 'your_consumer_secret'
access_token = 'your_access_token'
access_token_secret = 'your_access_token_secret'
```

> <span class="orange">Note</span>: We are storing them in a separate Python file than the main one because anyone who has access to these strings can use our Twitter account, so we don’t want to share these or make them public. Also, don’t commit these to a Git repository, instead, you can add them to .gitignore.


* Move into your tweetbot.py file and import the credentials to use. We’ll also add some lines to interact with the credential variables via the Tweepy library.
```ruby
import tweepy

# Import our Twitter credentials from credentials.py
from credentials import *

# Access and authorize our Twitter credentials from credentials.py
auth = tweepy.OAuthHandler(consumer_key, consumer_secret)
auth.set_access_token(access_token, access_token_secret)
api = tweepy.API(auth)
```

## Content for tweets & defining the functions
* Create a text file content.txt to get the content for the tweets. You could use anything that you like. I’m using the text from a book that I got from [Project Gutenberg ](https://www.gutenberg.org/), which provides free eBooks (mostly in the public domain) to readers. 

* Now we will create our variables and add relevant functions for them.

```ruby
import tweepy
from credentials import *

auth = tweepy.OAuthHandler(consumer_key, consumer_secret)
auth.set_access_token(access_token, access_token_secret)
api = tweepy.API(auth)

# Open text file content.txt (or your chosen file) for reading
my_file = open('content.txt', 'r')

# Read lines one by one from my_file and assign to file_lines variable
file_lines = my_file.readlines()

# Close file
my_file.close()
```

* Now that we have our lines stored in a variable, we are ready to tweet from our Twitter-bot account. To automate our tweets in a time-based way we will import the module time, we will only use sleep function here, so we import that only.

```ruby
# Add all import statements at top of the file
import tweepy
from time import sleep
from credentials import *
…
```

* For automation, we require a for loop to iterate over the lines from our content.txt file saved in file_lines variable. To see the output, we will print it out.

```ruby
import tweepy
from time import sleep
from credentials import *

auth = tweepy.OAuthHandler(consumer_key, consumer_secret)
auth.set_access_token(access_token, access_token_secret)
api = tweepy.API(auth)

my_file=open('content.txt','r')
file_lines=my_file.readlines()
my_file.close()

# Create a for loop to iterate over file_lines
for line in file_lines:
    print(line)
```

On running the program you could see that it’s printing out the lines into the terminal window from our text file.
We want every line as our new tweet and so we’ll use the tweepy function api.update_status(). This is used to update the authenticated user’s status, but will only update if the status is either: 1) not a duplicate, or 2) 140 characters or less.

Add the function by passing the line variable into it.
...
for line in file_lines:
    print(line)
    api.update_status(line)

Now, we have our working program with us, if we run it at this point, we won’t get far and get some error. We need to handle blank lines in our text
We’ll add an if statement that looks like this:
if line != '\n':
One more thing we should add is sleep() to ensure that these tweets don’t all go out at once. 
...
for line in file_lines:
  print(line)

# Add if statement to ensure that blank lines are skipped
  if line != '\n':
      api.update_status(line)

# Add an else statement with a pass to conclude the conditional statement
  else:
      pass

# Add sleep method to space tweets by 5 seconds each
  sleep(5)

We still need to handle one error for duplicate status, as we run our program again and again and it shouldn’t post the same tweets from the start.
To do that, we’ll add a try ... except block to our code, and have the console print out the reason for the error.

...
for line in file_lines:
# Add try ... except block to catch and output errors
    try:
        print(line)
        if line != '\n':
            api.update_status(line)
        else:
            pass
    except tweepy.TweepError as e:
        print(e.reason)
    sleep(5)

Now, we have our full working twitter bot. On running the program, you could see tweets updating from your account. You might want to increase the sleep time to sleep(3600) to tweet every one hour, just be aware of twitter’s API policies.

Because Twitterbots do ongoing and automated tasks, you may want to keep the program running even when your computer is sleeping or turned off. With a server, you can keep your program running as long as you would like. So, now we would put our bot on Heroku.

Firstly, push your code to a git repository and don’t forget to add credentials.py to .gitignore 
Log into your Heroku account or create one (https://signup.heroku.com/) if you don’t have. Heroku enables developers to build, run, and operate applications entirely in the cloud and you can create up to 5 apps for free.
Install the Heroku command-line interface https://devcenter.heroku.com/articles/heroku-cli
Once, its installed, initialize your repo with Heroku and it will generate a random URL
	$ heroku create
This operation will set up an app and also give a remote to your Git repo called heroku

Now, you need to create some files for telling Heroku what to do once it gets your code.
Create three files Procfile, requirements.txt and server.py

server.py:
We need to have some kind of web server that will listen on the Heroku PORT, otherwise, Heroku will think our app isn't working and it will be in the 'crashed' state. To satisfy this Heroku requirement, we can run a really simple Flask web server like this:
from os import environ
from flask import Flask

app = Flask(__name__)
app.run(host= '0.0.0.0', port=environ.get('PORT'))

requirements.txt:
This will list our dependencies, and it will be detected by Heroku and tell it that we are running a python app. Our file will look like this:

tweepy==3.8.0
django-heroku
Flask
To check the correct value for tweepy, you can type this in your terminal: 
pip freeze | grep tweepy 

Procfile:
Put this in your Procfile-
web: python server.py
worker: python tweetbot.py
The first command to connect the server and the second command will tell Heroku to do the equivalent of what you do in your terminal. 

Since Heroku uses Git repo for deployment, so constants from .gitignore won’t work. The last thing we will have to do is to set our environment variables in Heroku and then use os.environ to get them.
Firstly go to Heroku and in your app settings, you can add the 4 credentials variables one by one in Config Vars.
Also check in the overview tab in Heroku that the dynos are in on state, if not, turn them on.
Then come to your tweetbot.py file and add these lines at the top:
from os import environ
CONSUMER_KEY = environ['CONSUMER_KEY']
CONSUMER_SECRET = environ['CONSUMER_SECRET']
ACCESS_KEY = environ['ACCESS_KEY']
ACCESS_SECRET = environ['ACCESS_SECRET']

 Now, you just need to commit your code and push to heroku
	$git commit -m “message”
	$git push heroku master
Here I am deploying from the master branch, you could also deploy from a different branch by:
	$ git push heroku my_branch_name:master

Now, your app will be up and running. You can check activity logs from Heroku or else your Twitterbot account for seeing the status updates.











 

